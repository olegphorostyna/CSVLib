/*std::ifstream file_to_parse(argv[argc-1]);
    if(argc!=2) {
        std::cout<<"PLease provide file to parse"<<std::endl;
        return 0;
    }
    for(auto const&  row: readCSV(file_to_parse)){
        for(auto const& value: row) {
            std::cout<< value<<"    ";
        }
        std::cout<<std::endl;
    }
    file_to_parse.close();

    usd::UserImplementationTets new_user(1,"Jhon","Wick","Lviv,Stryiska,52","0878367278");
    usd::UserImplementationTets new_user2(2,"Semuele","Ketlo","Some","08783423478");
    usd::UserImplementationTets new_user3(3,"Willkoks","Pert","Think","0678798578");
    
    writeCSV("newFile", new_user);   
    writeCSV("newFile", new_user2);  
    writeCSV("newFile", new_user3);   

    usd::Query simpleQuerry  = usd::Query::QueryBuilder().
                                            setCol("Name").
                                            setCol("Ammount").
                                            setDistinct(true).
                                            setSmallerThan(1000).build();
    
    usd::Record record;   
    record.addColumn("Index", type::INT).addColumn("Name",type::STRING)
                                        .addColumn("Age",type::INT)
                                        .addColumn("Surname",type::STRING);

    record.printCellNames();
   
    record.setValue("Index",1).setValue("Age",20).setValue("Name","Andrew"); 

    record.printRecord();
    */



void writeCSV(std::string file_name, usd::SCValizable& to_csv ){
    std::ofstream file_to_write;
    file_to_write.open(file_name, std::fstream::app);
    std::vector<std::string> row = to_csv.toCSV(); 
    for(int i=0;i<row.size();i++){
         file_to_write<<"\""<<row.at(i)<<"\"";
         if(i!=(row.size()-1)){
              file_to_write<<",";
         }
    }  
    file_to_write<<std::endl;
    file_to_write.close();
}

    usd::CsvTable in_table("test.csv");    
    usd::CsvTable result_set;
    usd::Query test_get_cols = usd::Query::QueryBuilder().setCol("Name").setCol("Age").build();
    result_set.runQuery(in_table, test_get_cols);
    std::cout<<"Original table"<<"\n\n";
    in_table.printTable();
    std::cout<<"Result set"<<"\n\n";
    result_set.printTable(); 

select query: SELECT * FROM tab_name - select all the data in a table
	usd::Query::QueryBuilder().build();

select query: SELECT col1, col2, ... FROM tab_name - fields names of the table you want to select data from
	usd::Query::QueryBuilder().setCol("col1").setCol("col2").build();

select query: SELECT * FROM tab_name WHERE col_name = "value" - return records according to condition
	usd::Query::QueryBuilder().where(functor("col_name","value")).build(); //functor - is relational binary predicate 







#ifndef RECORD
#define RECORD

#include<string>
#include<vector>
#include <iostream>
#include <memory>
#include <algorithm>
#include "NoSuchColumn.h"
#include <cstring>
namespace usd{
    //Represent one record in a table
    class Record{  
        public:    
            Record(){}       
            ~Record() = default; 
            Record (const Record& r) = delete;
            Record& operator=(const Record& r)=delete;
            Record(Record&& r):row_(std::move(r.row_)){ };     
       
        enum Type{
            STRING,
            INT
        };
        private:
            struct Cell{                
                Cell(std::string n, Record::Type t):
                                                name(n),
                                                type(t){                                          
                                                };
                
              
                Cell(Cell&& c):name(c.name),
                                type(c.type),
                                data(c.data){
                    if(c.type == Record::Type::STRING){
                        c.data._str=nullptr;                       
                    }                               
                }
                
                ~Cell(){
                    if(type == Record::Type::STRING){
                        delete [] data._str;
                    }                    
                }

                std::string name;
                Record::Type type; 
                                             
                union {
                    int _int;
                    char* _str;
                } data;
                
                std::string getString(){                      
                    if(data._str ==nullptr){
                        return "";
                    }                 
                    return std::string(data._str);                     
                }

                std::string getName(){                    
                    return name;
                }

                int getInt(){
                    return data._int;
                }

                void setString(std::string in_str){                   
                    data._str = std::strcpy(new char[in_str.length()+1], in_str.c_str());                                           
                }

                void setInt(int in_int){
                    data._int=in_int;
                }
            };

            std::vector<std::unique_ptr<usd::Record::Cell>> row_;
            bool is_master_record_;
            
        public:
            Record& addColumn(std::string name, Record::Type type);
            Record& setValue(std::string col_name, std::string val);
            Record& setValue(std::string col_name, int val);            
            std::string getValue(std::string col_name);
            std::string getCellName(int);
            std::vector<std::string> toStrVector();
            int getCellCount();
            void printCellNames();
            void printRecord();
            void setAsMasterRecord(bool);
            bool isMasterRecord();
    };
}

#endif









